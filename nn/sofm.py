# -*- coding: utf-8 -*-
"""Practical 7 : Practical on Self-organizing Maps

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PGB8ClKhCK3MAf1tKa8fqH-sKsdFcqM6
"""

import numpy as np 

import matplotlib.pyplot as plt 

 

# Return the (g,h) index of the BMU in the grid 

def find_BMU(SOM,x): 

    distSq = (np.square(SOM - x)).sum(axis=2) 

    return np.unravel_index(np.argmin(distSq, axis=None), distSq.shape) 

 
 

     

# Update the weights of the SOM cells when given a single training example 

# and the model parameters along with BMU coordinates as a tuple 

def update_weights(SOM, train_ex, learn_rate, radius_sq,  

                   BMU_coord, step=3): 

    g, h = BMU_coord 

    #if radius is close to zero then only BMU is changed 

    if radius_sq < 1e-3: 

        SOM[g,h,:] += learn_rate * (train_ex - SOM[g,h,:]) 

        return SOM 

    # Change all cells in a small neighborhood of BMU 

    for i in range(max(0, g-step), min(SOM.shape[0], g+step)): 

        for j in range(max(0, h-step), min(SOM.shape[1], h+step)): 

            dist_sq = np.square(i - g) + np.square(j - h) 

            dist_func = np.exp(-dist_sq / 2 / radius_sq) 

            SOM[i,j,:] += learn_rate * dist_func * (train_ex - SOM[i,j,:])    

    return SOM     

 
 
 

# Main routine for training an SOM. It requires an initialized SOM grid 

# or a partially trained grid as parameter 

def train_SOM(SOM, train_data, learn_rate = .1, radius_sq = 1,  

             lr_decay = .1, radius_decay = .1, epochs = 10):     

    learn_rate_0 = learn_rate 

    radius_0 = radius_sq 

    for epoch in np.arange(0, epochs): 

        rand.shuffle(train_data)       

        for train_ex in train_data: 

            g, h = find_BMU(SOM, train_ex) 

            SOM = update_weights(SOM, train_ex,  

                                 learn_rate, radius_sq, (g,h)) 

        # Update learning rate and radius 

        learn_rate = learn_rate_0 * np.exp(-epoch * lr_decay) 

        radius_sq = radius_0 * np.exp(-epoch * radius_decay)             

    return SOM 

 

# Dimensions of the SOM grid 

m = 10 

n = 10 

# Number of training examples 

n_x = 3000 

rand = np.random.RandomState(0) 

# Initialize the training data 

train_data = rand.randint(0, 255, (n_x, 3)) 

# Initialize the SOM randomly 

SOM = rand.randint(0, 255, (m, n, 3)).astype(float) 

# Display both the training matrix and the SOM grid 

fig, ax = plt.subplots( 

    nrows=1, ncols=2, figsize=(12, 3.5),  

    subplot_kw=dict(xticks=[], yticks=[])) 

ax[0].imshow(train_data.reshape(50, 60, 3)) 

ax[0].title.set_text('Training Data') 

ax[1].imshow(SOM.astype(int)) 

ax[1].title.set_text('Randomly Initialized SOM Grid') 

 

fig, ax = plt.subplots( 

    nrows=4, ncols=4, figsize=(40, 40),  

    subplot_kw=dict(xticks=[], yticks=[])) 

total_epochs = 0 

 
 

# for learning rate .1 

for epochs, i in zip([10, 20, 50, 100], range(0,4)): 

    total_epochs += epochs 

    SOM = train_SOM(SOM, train_data, epochs=epochs) 

    ax[0][i].imshow(SOM.astype(int)) 

    ax[0][i].title.set_text('Epochs = ' + str(total_epochs) + ", learning rate = 0.1") 

 
 

# for learning rate .01 

for epochs, i in zip([10, 20, 50, 100], range(0,4)): 

    total_epochs += epochs 

    SOM = train_SOM(SOM, train_data,learn_rate = 0.01, epochs=epochs) 

    ax[1][i].imshow(SOM.astype(int)) 

    ax[1][i].title.set_text('Epochs = ' + str(total_epochs) + ", learning rate = 0.01") 

 
 

# for learning rate .001 

for epochs, i in zip([10, 20, 50, 100], range(0,4)): 

    total_epochs += epochs 

    SOM = train_SOM(SOM, train_data,learn_rate = 0.001, epochs=epochs) 

    ax[2][i].imshow(SOM.astype(int)) 

    ax[2][i].title.set_text('Epochs = ' + str(total_epochs) + ", learning rate = 0.001") 

 
 

# for learning rate .99 

for epochs, i in zip([10, 20, 50, 100], range(0,4)): 

    total_epochs += epochs 

    SOM = train_SOM(SOM, train_data,learn_rate = 0.99, epochs=epochs) 

    ax[3][i].imshow(SOM.astype(int)) 

    ax[3][i].title.set_text('Epochs = ' + str(total_epochs) + ", learning rate = 0.99")